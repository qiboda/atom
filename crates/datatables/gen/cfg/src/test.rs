
/*!
<auto-generated>
    This code was generated by a tool.
    Changes to this file may cause incorrect behavior and will be lost if
    the code is regenerated.
</auto-generated>
*/


use super::*;

bitflags::bitflags!{    
    #[derive(Debug, Hash, Eq, PartialEq)]
    pub struct AccessFlag : u32 {
        const WRITE = 1;
        const READ = 2;
        const TRUNCATE = 4;
        const NEW = 8;
        ///位标记使用示例
        const READ_WRITE = 3;
    }
}
#[derive(bevy::reflect::Reflect, Debug)]
pub struct MultiIndexList {
    pub id1: i32,
    pub id2: i32,
    pub id3: String,
    pub num: i32,
    pub desc: String,
}

impl MultiIndexList{
    pub fn new(json: &serde_json::Value) -> Result<MultiIndexList, LubanError> {
        let id1 = (json["id1"].as_i64().unwrap() as i32);
        let id2 = (json["id2"].as_i64().unwrap() as i32);
        let id3 = json["id3"].as_str().unwrap().to_string();
        let num = (json["num"].as_i64().unwrap() as i32);
        let desc = json["desc"].as_str().unwrap().to_string();
        
        Ok(MultiIndexList { id1, id2, id3, num, desc, })
    }
}

#[derive(bevy::reflect::Reflect, Debug)]
pub struct MultiUnionIndexList {
    pub id1: i32,
    pub id2: i32,
    pub id3: String,
    pub num: i32,
    pub desc: String,
}

impl MultiUnionIndexList{
    pub fn new(json: &serde_json::Value) -> Result<MultiUnionIndexList, LubanError> {
        let id1 = (json["id1"].as_i64().unwrap() as i32);
        let id2 = (json["id2"].as_i64().unwrap() as i32);
        let id3 = json["id3"].as_str().unwrap().to_string();
        let num = (json["num"].as_i64().unwrap() as i32);
        let desc = json["desc"].as_str().unwrap().to_string();
        
        Ok(MultiUnionIndexList { id1, id2, id3, num, desc, })
    }
}

#[derive(bevy::reflect::Reflect, Debug)]
pub struct NullIndexList {
    pub x: i32,
    pub y: i32,
}

impl NullIndexList{
    pub fn new(json: &serde_json::Value) -> Result<NullIndexList, LubanError> {
        let x = (json["x"].as_i64().unwrap() as i32);
        let y = (json["y"].as_i64().unwrap() as i32);
        
        Ok(NullIndexList { x, y, })
    }
}

#[derive(bevy::reflect::Reflect, Debug)]
pub struct Shape {
}

impl Shape {
    pub fn new(json: &serde_json::Value) -> Result<std::sync::Arc<AbstractBase>, LubanError> {
        let type_id = json["$type"].as_str().unwrap();
        match type_id {
            "Circle" => Ok(std::sync::Arc::new(crate::test::Circle::new(json)?)),
            "Rectangle" => Ok(std::sync::Arc::new(crate::test::Rectangle::new(json)?)),
            _ => Err(LubanError::Bean(format!("Invalid type for Shape:{}", type_id)))
        }
    }
}

pub trait TShape {
}

impl crate::test::TShape for crate::test::Circle {
}

impl crate::test::TShape for crate::test::Rectangle {
}

impl<'a> GetBase<'a, &'a dyn crate::test::TShape> for AbstractBase {
    fn get_base(&'a self) -> Result<&'a dyn crate::test::TShape, LubanError> {
        let base: Result<&crate::test::Circle, _> = self.try_into();
        if let Ok(r) = base {
            return Ok(r);
        }
        let base: Result<&crate::test::Rectangle, _> = self.try_into();
        if let Ok(r) = base {
            return Ok(r);
        }

        Err(LubanError::Polymorphic("Invalid type for Shape".to_string()))
    }
}

#[derive(bevy::reflect::Reflect, Debug)]
#[derive(macros::TryIntoBase)]
pub struct Circle {
    /// 半径
    pub radius: f32,
}

impl Circle{
    pub fn new(json: &serde_json::Value) -> Result<Circle, LubanError> {
        let radius = (json["radius"].as_f64().unwrap() as f32);
        
        Ok(Circle { radius, })
    }
}

#[derive(bevy::reflect::Reflect, Debug)]
#[derive(macros::TryIntoBase)]
pub struct Rectangle {
    /// 宽度
    pub width: f32,
    /// 高度
    pub height: f32,
}

impl Rectangle{
    pub fn new(json: &serde_json::Value) -> Result<Rectangle, LubanError> {
        let width = (json["width"].as_f64().unwrap() as f32);
        let height = (json["height"].as_f64().unwrap() as f32);
        
        Ok(Rectangle { width, height, })
    }
}

#[derive(bevy::reflect::Reflect, Debug)]
pub struct TestExcelBean1 {
    /// 最高品质
    pub x1: i32,
    /// 黑色的
    pub x2: String,
    /// 蓝色的
    pub x3: i32,
    /// 最差品质
    pub x4: f32,
}

impl TestExcelBean1{
    pub fn new(json: &serde_json::Value) -> Result<TestExcelBean1, LubanError> {
        let x1 = (json["x1"].as_i64().unwrap() as i32);
        let x2 = json["x2"].as_str().unwrap().to_string();
        let x3 = (json["x3"].as_i64().unwrap() as i32);
        let x4 = (json["x4"].as_f64().unwrap() as f32);
        
        Ok(TestExcelBean1 { x1, x2, x3, x4, })
    }
}

#[derive(bevy::reflect::Reflect, Debug)]
pub struct TestExcelBean2 {
    /// 最高品质
    pub y1: i32,
    /// 黑色的
    pub y2: String,
    /// 蓝色的
    pub y3: f32,
}

impl TestExcelBean2{
    pub fn new(json: &serde_json::Value) -> Result<TestExcelBean2, LubanError> {
        let y1 = (json["y1"].as_i64().unwrap() as i32);
        let y2 = json["y2"].as_str().unwrap().to_string();
        let y3 = (json["y3"].as_f64().unwrap() as f32);
        
        Ok(TestExcelBean2 { y1, y2, y3, })
    }
}


#[derive(Debug, bevy::reflect::Reflect, bevy::asset::Asset)]
pub struct TbMultiIndexList {
    pub data_list: Vec<std::sync::Arc<crate::test::MultiIndexList>>,
    pub data_map_id1: bevy::utils::HashMap<i32, std::sync::Arc<crate::test::MultiIndexList>>,
    pub data_map_id2: bevy::utils::HashMap<i32, std::sync::Arc<crate::test::MultiIndexList>>,
    pub data_map_id3: bevy::utils::HashMap<String, std::sync::Arc<crate::test::MultiIndexList>>,
}

impl TbMultiIndexList {
    pub fn new(json: &serde_json::Value) -> Result<TbMultiIndexList, LubanError> {
        let mut data_list: Vec<std::sync::Arc<crate::test::MultiIndexList>> = vec![];

        for x in json.as_array().unwrap() {
            let row = std::sync::Arc::new(crate::test::MultiIndexList::new(&x)?);
            data_list.push(row.clone());
        }
        let mut data_map_id1: bevy::utils::HashMap<i32, std::sync::Arc<crate::test::MultiIndexList>> = Default::default();
        let mut data_map_id2: bevy::utils::HashMap<i32, std::sync::Arc<crate::test::MultiIndexList>> = Default::default();
        let mut data_map_id3: bevy::utils::HashMap<String, std::sync::Arc<crate::test::MultiIndexList>> = Default::default();
        for x in &data_list {
            data_map_id1.insert(x.id1.clone(), x.clone());
            data_map_id2.insert(x.id2.clone(), x.clone());
            data_map_id3.insert(x.id3.clone(), x.clone());
        }

    Ok(TbMultiIndexList { 
            data_list,
            data_map_id1,
            data_map_id2,
            data_map_id3,
        })
    }

    pub fn get_by_id1(&self, key: &i32) -> Option<std::sync::Arc<crate::test::MultiIndexList>> {
        self.data_map_id1.get(key).map(|x| x.clone())
    }
    pub fn get_by_id2(&self, key: &i32) -> Option<std::sync::Arc<crate::test::MultiIndexList>> {
        self.data_map_id2.get(key).map(|x| x.clone())
    }
    pub fn get_by_id3(&self, key: &String) -> Option<std::sync::Arc<crate::test::MultiIndexList>> {
        self.data_map_id3.get(key).map(|x| x.clone())
    }
}

impl luban_lib::table::Table for TbMultiIndexList {
    type Value = std::sync::Arc<crate::test::MultiIndexList>;
}
impl luban_lib::table::ListTable for TbMultiIndexList {}


#[derive(Debug, bevy::reflect::Reflect)]
pub enum TbMultiIndexListKey {
    Id1(i32),
    Id2(i32),
    Id3(String),
}

#[derive(Debug, bevy::reflect::Reflect)]
pub enum TbMultiIndexListMap<'a> {
    Id1(&'a bevy::utils::HashMap<i32, std::sync::Arc<crate::test::MultiIndexList>>),
    Id2(&'a bevy::utils::HashMap<i32, std::sync::Arc<crate::test::MultiIndexList>>),
    Id3(&'a bevy::utils::HashMap<String, std::sync::Arc<crate::test::MultiIndexList>>),
}

impl<'a> luban_lib::table::MultiIndexListTable<'a> for TbMultiIndexList {
    type Key = TbMultiIndexListKey;
    type List = Vec<std::sync::Arc<crate::test::MultiIndexList>>;
    type Map = TbMultiIndexListMap<'a>;

    fn get_row_by(&self, key: &Self::Key) -> Option<Self::Value> {
        match key {
            TbMultiIndexListKey::Id1(key) => self.data_map_id1.get(key).map(|x| x.clone()),
            TbMultiIndexListKey::Id2(key) => self.data_map_id2.get(key).map(|x| x.clone()),
            TbMultiIndexListKey::Id3(key) => self.data_map_id3.get(key).map(|x| x.clone()),
        }
    }

    fn get_data_list(&self) -> &Self::List {
        &self.data_list
    }

    fn get_data_map_by(&'a self, key: &Self::Key) -> Self::Map {
        match key {
            TbMultiIndexListKey::Id1(key) => TbMultiIndexListMap::Id1(&self.data_map_id1),
            TbMultiIndexListKey::Id2(key) => TbMultiIndexListMap::Id2(&self.data_map_id2),
            TbMultiIndexListKey::Id3(key) => TbMultiIndexListMap::Id3(&self.data_map_id3),
        }
    }
}


#[derive(Debug, Default)]
pub struct TbMultiIndexListLoader;

impl bevy::asset::AssetLoader for TbMultiIndexListLoader {
    type Asset = TbMultiIndexList;

    type Settings = ();

    type Error = TableLoaderError;

    async fn load(
        &self,
        reader: &mut dyn bevy::asset::io::Reader,
        settings: &Self::Settings,
        load_context: &mut bevy::asset::LoadContext<'_>,
    ) -> Result<Self::Asset, Self::Error> {
        bevy::log::info!("TbMultiIndexListLoader loading start");
        let mut bytes = Vec::new();
        use bevy::asset::AsyncReadExt;
        reader.read_to_end(&mut bytes).await?;
        let t = serde_json::from_slice::<serde_json::Value>(&bytes)?;
        let tb = TbMultiIndexList::new(&t).unwrap();
        bevy::log::info!("TbMultiIndexListLoader loading over");
        Ok(tb)
    }

    fn extensions(&self) -> &[&str] {
        &["json"]
    }
}


#[derive(Debug, bevy::reflect::Reflect, bevy::asset::Asset)]
pub struct TbMultiUnionIndexList {
    pub data_list: Vec<std::sync::Arc<crate::test::MultiUnionIndexList>>,
    pub data_map_union: bevy::utils::HashMap<(i32, i32, String), std::sync::Arc<crate::test::MultiUnionIndexList>>,
}

impl TbMultiUnionIndexList {
    pub fn new(json: &serde_json::Value) -> Result<TbMultiUnionIndexList, LubanError> {
        let mut data_list: Vec<std::sync::Arc<crate::test::MultiUnionIndexList>> = vec![];

        for x in json.as_array().unwrap() {
            let row = std::sync::Arc::new(crate::test::MultiUnionIndexList::new(&x)?);
            data_list.push(row.clone());
        }
        let mut data_map_union: bevy::utils::HashMap<(i32, i32, String), std::sync::Arc<crate::test::MultiUnionIndexList>> = Default::default();
        for x in &data_list {
            data_map_union.insert((x.id1, x.id2, x.id3.clone()), x.clone());
        }

    Ok(TbMultiUnionIndexList { 
            data_list,
            data_map_union,
        })
    }

    pub fn get(&self, key: &(i32, i32, String)) -> Option<std::sync::Arc<crate::test::MultiUnionIndexList>> {
        self.data_map_union.get(key).map(|x| x.clone())
    }
}

impl luban_lib::table::Table for TbMultiUnionIndexList {
    type Value = std::sync::Arc<crate::test::MultiUnionIndexList>;
}
impl luban_lib::table::ListTable for TbMultiUnionIndexList {}


pub type TbMultiUnionIndexListKey = (i32, i32, String);
#[derive(Debug, Default, Clone, bevy::reflect::Reflect, bevy::prelude::Component, serde::Serialize, serde::Deserialize)]
pub struct TbMultiUnionIndexListRow {
    pub key: TbMultiUnionIndexListKey,
    #[serde(skip)]
    pub data: Option<std::sync::Arc<crate::test::MultiUnionIndexList>>,
}

impl PartialEq for TbMultiUnionIndexListRow {
    fn eq(&self, other: &Self) -> bool {
        self.key == other.key
    }
}

impl luban_lib::table::MultiUnionIndexListTable for TbMultiUnionIndexList {
    type Key = TbMultiUnionIndexListKey;
    type List = Vec<std::sync::Arc<crate::test::MultiUnionIndexList>>;
    type Map = bevy::utils::HashMap<Self::Key, Self::Value>;

    fn get_row_by_key(&self, key: &Self::Key) -> Option<Self::Value> {
        self.data_map_union.get(key).map(|x| x.clone())
    }

    fn get_data_list(&self) -> &Self::List {
        &self.data_list
    }

    fn get_data_map(&self) -> &Self::Map {
        &self.data_map_union
    }
}


#[derive(Debug, Default)]
pub struct TbMultiUnionIndexListLoader;

impl bevy::asset::AssetLoader for TbMultiUnionIndexListLoader {
    type Asset = TbMultiUnionIndexList;

    type Settings = ();

    type Error = TableLoaderError;

    async fn load(
        &self,
        reader: &mut dyn bevy::asset::io::Reader,
        settings: &Self::Settings,
        load_context: &mut bevy::asset::LoadContext<'_>,
    ) -> Result<Self::Asset, Self::Error> {
        bevy::log::info!("TbMultiUnionIndexListLoader loading start");
        let mut bytes = Vec::new();
        use bevy::asset::AsyncReadExt;
        reader.read_to_end(&mut bytes).await?;
        let t = serde_json::from_slice::<serde_json::Value>(&bytes)?;
        let tb = TbMultiUnionIndexList::new(&t).unwrap();
        bevy::log::info!("TbMultiUnionIndexListLoader loading over");
        Ok(tb)
    }

    fn extensions(&self) -> &[&str] {
        &["json"]
    }
}


#[derive(Debug, bevy::reflect::Reflect, bevy::asset::Asset)]
pub struct TbNullIndexList {
    pub data_list: Vec<std::sync::Arc<crate::test::NullIndexList>>,
}

impl TbNullIndexList {
    pub fn new(json: &serde_json::Value) -> Result<TbNullIndexList, LubanError> {
        let mut data_list: Vec<std::sync::Arc<crate::test::NullIndexList>> = vec![];

        for x in json.as_array().unwrap() {
            let row = std::sync::Arc::new(crate::test::NullIndexList::new(&x)?);
            data_list.push(row.clone());
        }

    Ok(TbNullIndexList { 
            data_list,
        })
    }

}

impl luban_lib::table::Table for TbNullIndexList {
    type Value = std::sync::Arc<crate::test::NullIndexList>;
}
impl luban_lib::table::ListTable for TbNullIndexList {}


impl luban_lib::table::NotIndexListTable for TbNullIndexList {
    type List = Vec<Self::Value>;
    fn iter(&self) -> impl Iterator<Item=&Self::Value> {
        self.data_list.iter()
    }

    fn get_data_list(&self) -> &Self::List {
        &self.data_list
    }
}



#[derive(Debug, Default)]
pub struct TbNullIndexListLoader;

impl bevy::asset::AssetLoader for TbNullIndexListLoader {
    type Asset = TbNullIndexList;

    type Settings = ();

    type Error = TableLoaderError;

    async fn load(
        &self,
        reader: &mut dyn bevy::asset::io::Reader,
        settings: &Self::Settings,
        load_context: &mut bevy::asset::LoadContext<'_>,
    ) -> Result<Self::Asset, Self::Error> {
        bevy::log::info!("TbNullIndexListLoader loading start");
        let mut bytes = Vec::new();
        use bevy::asset::AsyncReadExt;
        reader.read_to_end(&mut bytes).await?;
        let t = serde_json::from_slice::<serde_json::Value>(&bytes)?;
        let tb = TbNullIndexList::new(&t).unwrap();
        bevy::log::info!("TbNullIndexListLoader loading over");
        Ok(tb)
    }

    fn extensions(&self) -> &[&str] {
        &["json"]
    }
}


