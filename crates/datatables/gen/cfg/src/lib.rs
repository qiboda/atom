
/*!
<auto-generated>
    This code was generated by a tool.
    Changes to this file may cause incorrect behavior and will be lost if
    the code is regenerated.
</auto-generated>
*/

#![allow(warnings)]
#![allow(clippy::all)]




pub mod prelude{
    pub use crate::*;
    pub use crate::effect::*;
    pub use crate::layertag::*;
    pub use crate::unit::*;
    pub use crate::item::*;
    pub use crate::global::*;
    pub use crate::test::*;
}

use crate::effect::*;
use crate::layertag::*;
use crate::unit::*;
use crate::item::*;
use crate::global::*;
use crate::test::*;


type AbstractBase = dyn std::any::Any + Sync + Send;

pub trait GetBase<'a, T> {
    fn get_base(&'a self) -> Result<T, LubanError>;
}

#[derive(Debug)]
pub enum LubanError {
    Loader(String),
    Table(String),
    Bean(String),
    Polymorphic(String),
    Unknown(String),
}

impl std::error::Error for LubanError {}

impl std::fmt::Display for LubanError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.write_str(match self {
            LubanError::Loader(msg) |
            LubanError::Table(msg) |
            LubanError::Bean(msg) |
            LubanError::Polymorphic(msg) |
            LubanError::Unknown(msg) => msg,
        })
    }
}
    
#[derive(Debug, thiserror::Error)]
pub enum TableLoaderError {
    #[error("serde json error: {0}")]
    SerdeJsonError(#[from] serde_json::error::Error),
    #[error("io error: {0}")]
    IOError(#[from] std::io::Error),
    #[error("luban error: {0}")]
    LubanError(#[from] LubanError),
}

#[derive(Debug, bevy::prelude::Resource, Default)]
pub struct Tables{
    pub tb_ability: bevy::asset::Handle<crate::effect::TbAbility>,
    pub tb_buff: bevy::asset::Handle<crate::effect::TbBuff>,
    pub tb_layer_tag: bevy::asset::Handle<crate::layertag::TbLayerTag>,
    pub tb_monster: bevy::asset::Handle<crate::unit::TbMonster>,
    pub tb_npc: bevy::asset::Handle<crate::unit::TbNpc>,
    pub tb_player: bevy::asset::Handle<crate::unit::TbPlayer>,
    pub tb_relation_ship: bevy::asset::Handle<crate::unit::TbRelationShip>,
    pub tb_item: bevy::asset::Handle<crate::item::TbItem>,
    pub tb_global: bevy::asset::Handle<crate::global::TbGlobal>,
    pub tb_multi_index_list: bevy::asset::Handle<crate::test::TbMultiIndexList>,
    pub tb_multi_union_index_list: bevy::asset::Handle<crate::test::TbMultiUnionIndexList>,
    pub tb_null_index_list: bevy::asset::Handle<crate::test::TbNullIndexList>,
    pub table_handle_map: bevy::utils::HashMap<std::any::TypeId, bevy::asset::UntypedHandle>,
}

impl Tables {
    pub fn new<G: Clone + Send + Sync + 'static>(asset_server: bevy::prelude::Res<bevy::asset::AssetServer>, tables_path: std::path::PathBuf, guard: G) -> Tables {
        let mut tables = Tables {
            tb_ability: asset_server.load_acquire(tables_path.join("effect_tbability.json"), guard.clone()),
            tb_buff: asset_server.load_acquire(tables_path.join("effect_tbbuff.json"), guard.clone()),
            tb_layer_tag: asset_server.load_acquire(tables_path.join("layertag_tblayertag.json"), guard.clone()),
            tb_monster: asset_server.load_acquire(tables_path.join("unit_tbmonster.json"), guard.clone()),
            tb_npc: asset_server.load_acquire(tables_path.join("unit_tbnpc.json"), guard.clone()),
            tb_player: asset_server.load_acquire(tables_path.join("unit_tbplayer.json"), guard.clone()),
            tb_relation_ship: asset_server.load_acquire(tables_path.join("unit_tbrelationship.json"), guard.clone()),
            tb_item: asset_server.load_acquire(tables_path.join("item_tbitem.json"), guard.clone()),
            tb_global: asset_server.load_acquire(tables_path.join("global_tbglobal.json"), guard.clone()),
            tb_multi_index_list: asset_server.load_acquire(tables_path.join("test_tbmultiindexlist.json"), guard.clone()),
            tb_multi_union_index_list: asset_server.load_acquire(tables_path.join("test_tbmultiunionindexlist.json"), guard.clone()),
            tb_null_index_list: asset_server.load_acquire(tables_path.join("test_tbnullindexlist.json"), guard.clone()),
            table_handle_map: bevy::utils::HashMap::default(),
        };

        tables.table_handle_map.insert(std::any::TypeId::of::<crate::effect::TbAbility>(), tables.tb_ability.clone_weak().untyped());
        tables.table_handle_map.insert(std::any::TypeId::of::<crate::effect::TbBuff>(), tables.tb_buff.clone_weak().untyped());
        tables.table_handle_map.insert(std::any::TypeId::of::<crate::layertag::TbLayerTag>(), tables.tb_layer_tag.clone_weak().untyped());
        tables.table_handle_map.insert(std::any::TypeId::of::<crate::unit::TbMonster>(), tables.tb_monster.clone_weak().untyped());
        tables.table_handle_map.insert(std::any::TypeId::of::<crate::unit::TbNpc>(), tables.tb_npc.clone_weak().untyped());
        tables.table_handle_map.insert(std::any::TypeId::of::<crate::unit::TbPlayer>(), tables.tb_player.clone_weak().untyped());
        tables.table_handle_map.insert(std::any::TypeId::of::<crate::unit::TbRelationShip>(), tables.tb_relation_ship.clone_weak().untyped());
        tables.table_handle_map.insert(std::any::TypeId::of::<crate::item::TbItem>(), tables.tb_item.clone_weak().untyped());
        tables.table_handle_map.insert(std::any::TypeId::of::<crate::global::TbGlobal>(), tables.tb_global.clone_weak().untyped());
        tables.table_handle_map.insert(std::any::TypeId::of::<crate::test::TbMultiIndexList>(), tables.tb_multi_index_list.clone_weak().untyped());
        tables.table_handle_map.insert(std::any::TypeId::of::<crate::test::TbMultiUnionIndexList>(), tables.tb_multi_union_index_list.clone_weak().untyped());
        tables.table_handle_map.insert(std::any::TypeId::of::<crate::test::TbNullIndexList>(), tables.tb_null_index_list.clone_weak().untyped());

        tables
    }

    pub fn get_table_handle<T: 'static + bevy::asset::Asset>(&self) -> Result<bevy::asset::Handle<T>, LubanError> {
        self.table_handle_map
            .get(&std::any::TypeId::of::<T>())
            .map(|handle| handle.clone_weak().typed())
            .ok_or(LubanError::Table(format!("table not found: {}", std::any::type_name::<T>())))
    }
}

#[derive(Default)]
pub struct TableAssetsPlugin;

impl bevy::app::Plugin for TableAssetsPlugin {
    fn build(&self, app: &mut bevy::app::App) {
        use bevy::asset::AssetApp;
        app
            .add_event::<TablesLoadedEvent>()
            .init_asset_loader::<TbAbilityLoader>()
            .init_asset::<TbAbility>()
            .add_systems(bevy::app::PreUpdate, table_asset_loadeds::<TbAbility>)
            .init_asset_loader::<TbBuffLoader>()
            .init_asset::<TbBuff>()
            .add_systems(bevy::app::PreUpdate, table_asset_loadeds::<TbBuff>)
            .init_asset_loader::<TbLayerTagLoader>()
            .init_asset::<TbLayerTag>()
            .add_systems(bevy::app::PreUpdate, table_asset_loadeds::<TbLayerTag>)
            .init_asset_loader::<TbMonsterLoader>()
            .init_asset::<TbMonster>()
            .add_systems(bevy::app::PreUpdate, table_asset_loadeds::<TbMonster>)
            .init_asset_loader::<TbNpcLoader>()
            .init_asset::<TbNpc>()
            .add_systems(bevy::app::PreUpdate, table_asset_loadeds::<TbNpc>)
            .init_asset_loader::<TbPlayerLoader>()
            .init_asset::<TbPlayer>()
            .add_systems(bevy::app::PreUpdate, table_asset_loadeds::<TbPlayer>)
            .init_asset_loader::<TbRelationShipLoader>()
            .init_asset::<TbRelationShip>()
            .add_systems(bevy::app::PreUpdate, table_asset_loadeds::<TbRelationShip>)
            .init_asset_loader::<TbItemLoader>()
            .init_asset::<TbItem>()
            .add_systems(bevy::app::PreUpdate, table_asset_loadeds::<TbItem>)
            .init_asset_loader::<TbGlobalLoader>()
            .init_asset::<TbGlobal>()
            .add_systems(bevy::app::PreUpdate, table_asset_loadeds::<TbGlobal>)
            .init_asset_loader::<TbMultiIndexListLoader>()
            .init_asset::<TbMultiIndexList>()
            .add_systems(bevy::app::PreUpdate, table_asset_loadeds::<TbMultiIndexList>)
            .init_asset_loader::<TbMultiUnionIndexListLoader>()
            .init_asset::<TbMultiUnionIndexList>()
            .add_systems(bevy::app::PreUpdate, table_asset_loadeds::<TbMultiUnionIndexList>)
            .init_asset_loader::<TbNullIndexListLoader>()
            .init_asset::<TbNullIndexList>()
            .add_systems(bevy::app::PreUpdate, table_asset_loadeds::<TbNullIndexList>)
            ;
    }
}

#[derive(Debug, bevy::ecs::event::Event)]
pub struct TablesLoadedEvent {
    pub asset_handles: smallvec::SmallVec<[bevy::asset::UntypedHandle;1]>,
}


fn table_asset_loadeds<A: bevy::asset::Asset>(
    mut event_reader: bevy::prelude::EventReader<bevy::asset::AssetEvent<A>>,
    mut event_writer: bevy::prelude::EventWriter<TablesLoadedEvent>,
    tables: bevy::prelude::Res<Tables>,
    asset_server: bevy::prelude::Res<bevy::asset::AssetServer>,
) {
    let mut asset_handles = smallvec::SmallVec::<[bevy::asset::UntypedHandle;1]>::new();
    for event in event_reader.read() {
        if let bevy::asset::AssetEvent::<A>::Modified { id } = event {
           if tables.table_handle_map.iter().all(|(k, v)| {
                asset_server.is_loaded(v)
            }) {
                let handle = asset_server.get_id_handle(*id).unwrap();
                asset_handles.push(handle.untyped());
            }
        }
    }
    if asset_handles.len() > 0 {
        event_writer.send(TablesLoadedEvent { asset_handles });
    }
}

#[derive(Default)]
pub struct TableProtocolPlugin;

impl bevy::app::Plugin for TableProtocolPlugin {
    fn build(&self, app: &mut bevy::prelude::App) {
        use client::ComponentSyncMode;
        use lightyear::prelude::*;
        app.register_component::<TbAbilityRow>(ChannelDirection::ServerToClient)
            .add_prediction(ComponentSyncMode::Once);
        app.register_component::<TbBuffRow>(ChannelDirection::ServerToClient)
            .add_prediction(ComponentSyncMode::Once);
        app.register_component::<TbLayerTagRow>(ChannelDirection::ServerToClient)
            .add_prediction(ComponentSyncMode::Once);
        app.register_component::<TbMonsterRow>(ChannelDirection::ServerToClient)
            .add_prediction(ComponentSyncMode::Once);
        app.register_component::<TbNpcRow>(ChannelDirection::ServerToClient)
            .add_prediction(ComponentSyncMode::Once);
        app.register_component::<TbPlayerRow>(ChannelDirection::ServerToClient)
            .add_prediction(ComponentSyncMode::Once);
        app.register_component::<TbRelationShipRow>(ChannelDirection::ServerToClient)
            .add_prediction(ComponentSyncMode::Once);
        app.register_component::<TbItemRow>(ChannelDirection::ServerToClient)
            .add_prediction(ComponentSyncMode::Once);
        app.register_component::<TbMultiUnionIndexListRow>(ChannelDirection::ServerToClient)
            .add_prediction(ComponentSyncMode::Once);
    }
}

pub mod effect;
pub mod layertag;
pub mod unit;
pub mod item;
pub mod global;
pub mod test;


#[derive(bevy::reflect::Reflect, Debug)]
pub struct vector2 {
    pub x: f32,
    pub y: f32,
}

impl vector2{
    pub fn new(json: &serde_json::Value) -> Result<vector2, LubanError> {
        let x = (json["x"].as_f64().unwrap() as f32);
        let y = (json["y"].as_f64().unwrap() as f32);
        
        Ok(vector2 { x, y, })
    }
}

#[derive(bevy::reflect::Reflect, Debug)]
pub struct vector3 {
    pub x: f32,
    pub y: f32,
    pub z: f32,
}

impl vector3{
    pub fn new(json: &serde_json::Value) -> Result<vector3, LubanError> {
        let x = (json["x"].as_f64().unwrap() as f32);
        let y = (json["y"].as_f64().unwrap() as f32);
        let z = (json["z"].as_f64().unwrap() as f32);
        
        Ok(vector3 { x, y, z, })
    }
}

#[derive(bevy::reflect::Reflect, Debug)]
pub struct vector4 {
    pub x: f32,
    pub y: f32,
    pub z: f32,
    pub w: f32,
}

impl vector4{
    pub fn new(json: &serde_json::Value) -> Result<vector4, LubanError> {
        let x = (json["x"].as_f64().unwrap() as f32);
        let y = (json["y"].as_f64().unwrap() as f32);
        let z = (json["z"].as_f64().unwrap() as f32);
        let w = (json["w"].as_f64().unwrap() as f32);
        
        Ok(vector4 { x, y, z, w, })
    }
}


