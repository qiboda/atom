/*!
<auto-generated>
    This code was generated by a tool.
    Changes to this file may cause incorrect behavior and will be lost if
    the code is regenerated.
</auto-generated>
*/

use super::*;

///ability active or passive type
#[derive(Debug, Hash, Eq, PartialEq, bevy::reflect::Reflect, macros::EnumFromNum)]
pub enum AbilityType {
    Active = 0,
    Passive = 1,
}

impl From<i32> for AbilityType {
    fn from(value: i32) -> Self {
        match value {
            0 => AbilityType::Active,
            1 => AbilityType::Passive,
            _ => panic!("Invalid value for AbilityType:{}", value),
        }
    }
}

#[derive(bevy::reflect::Reflect, Debug)]
pub struct RevertableLayerTag {
    pub raw_layertag: String,
    pub revertable: bool,
}

impl RevertableLayerTag {
    pub fn new(mut buf: &mut luban_lib::ByteBuf) -> Result<RevertableLayerTag, LubanError> {
        let raw_layertag = buf.read_string();
        let revertable = buf.read_bool();

        Ok(RevertableLayerTag {
            raw_layertag,
            revertable,
        })
    }

    pub const __ID__: i32 = 136820612;
}

#[derive(Debug, bevy::reflect::Reflect, bevy::asset::Asset)]
pub struct TbAbility {
    pub data_list: Vec<std::sync::Arc<crate::Ability>>,
    pub data_map: bevy::utils::HashMap<i32, std::sync::Arc<crate::Ability>>,
}

impl TbAbility {
    pub fn new(mut buf: luban_lib::ByteBuf) -> Result<TbAbility, LubanError> {
        let mut data_map: bevy::utils::HashMap<i32, std::sync::Arc<crate::Ability>> =
            Default::default();
        let mut data_list: Vec<std::sync::Arc<crate::Ability>> = vec![];

        for x in (0..buf.read_size()).rev() {
            let row = std::sync::Arc::new(crate::Ability::new(&mut buf)?);
            data_list.push(row.clone());
            data_map.insert(row.id.clone(), row.clone());
        }

        Ok(TbAbility {
            data_map,
            data_list,
        })
    }

    pub fn get(&self, key: &i32) -> Option<std::sync::Arc<crate::Ability>> {
        self.data_map.get(key).map(|x| x.clone())
    }
}

impl std::ops::Index<i32> for TbAbility {
    type Output = std::sync::Arc<crate::Ability>;

    fn index(&self, index: i32) -> &Self::Output {
        &self.data_map.get(&index).unwrap()
    }
}
impl luban_lib::table::Table for TbAbility {
    type Value = std::sync::Arc<crate::Ability>;
}
pub type TbAbilityKey = i32;
#[derive(Debug, Default, Clone, bevy::reflect::Reflect, bevy::prelude::Component)]
pub struct TbAbilityRow {
    pub key: TbAbilityKey,
    pub data: Option<std::sync::Arc<crate::Ability>>,
}

impl TbAbilityRow {
    pub fn new(key: TbAbilityKey, data: Option<std::sync::Arc<crate::Ability>>) -> Self {
        Self { key, data }
    }

    pub fn key(&self) -> &TbAbilityKey {
        &self.key
    }

    pub fn set_key(&mut self, key: TbAbilityKey) {
        self.key = key;
    }

    pub fn set_data(&mut self, data: Option<std::sync::Arc<crate::Ability>>) {
        self.data = data;
    }

    pub fn get_data(&self) -> Option<std::sync::Arc<crate::Ability>> {
        self.data.clone()
    }

    pub fn data(&self) -> std::sync::Arc<crate::Ability> {
        self.data.clone().unwrap()
    }
}

impl luban_lib::table::MapTable for TbAbility {
    type Key = TbAbilityKey;
    type List = Vec<std::sync::Arc<crate::Ability>>;
    type Map = bevy::utils::HashMap<Self::Key, Self::Value>;

    fn get_row(&self, key: &Self::Key) -> Option<Self::Value> {
        self.data_map.get(key).map(|x| x.clone())
    }

    fn get_data_list(&self) -> &Self::List {
        &self.data_list
    }

    fn get_data_map(&self) -> &Self::Map {
        &self.data_map
    }
}

#[derive(Debug, Default)]
pub struct TbAbilityLoader;

impl bevy::asset::AssetLoader for TbAbilityLoader {
    type Asset = TbAbility;

    type Settings = ();

    type Error = TableLoaderError;

    async fn load<'a>(
        &'a self,
        reader: &'a mut bevy::asset::io::Reader<'_>,
        settings: &'a Self::Settings,
        load_context: &'a mut bevy::asset::LoadContext<'_>,
    ) -> Result<Self::Asset, Self::Error> {
        bevy::log::info!("TbAbilityLoader loading start");
        let mut bytes = Vec::new();
        use bevy::asset::AsyncReadExt;
        reader.read_to_end(&mut bytes).await?;
        let buf = luban_lib::ByteBuf::new(bytes);
        let tb = TbAbility::new(buf).unwrap();
        bevy::log::info!("TbAbilityLoader loading over");
        Ok(tb)
    }

    fn extensions(&self) -> &[&str] {
        &["bytes"]
    }
}

#[derive(Debug, bevy::reflect::Reflect, bevy::asset::Asset)]
pub struct TbBuff {
    pub data_list: Vec<std::sync::Arc<crate::Buff>>,
    pub data_map: bevy::utils::HashMap<i32, std::sync::Arc<crate::Buff>>,
}

impl TbBuff {
    pub fn new(mut buf: luban_lib::ByteBuf) -> Result<TbBuff, LubanError> {
        let mut data_map: bevy::utils::HashMap<i32, std::sync::Arc<crate::Buff>> =
            Default::default();
        let mut data_list: Vec<std::sync::Arc<crate::Buff>> = vec![];

        for x in (0..buf.read_size()).rev() {
            let row = std::sync::Arc::new(crate::Buff::new(&mut buf)?);
            data_list.push(row.clone());
            data_map.insert(row.id.clone(), row.clone());
        }

        Ok(TbBuff {
            data_map,
            data_list,
        })
    }

    pub fn get(&self, key: &i32) -> Option<std::sync::Arc<crate::Buff>> {
        self.data_map.get(key).map(|x| x.clone())
    }
}

impl std::ops::Index<i32> for TbBuff {
    type Output = std::sync::Arc<crate::Buff>;

    fn index(&self, index: i32) -> &Self::Output {
        &self.data_map.get(&index).unwrap()
    }
}
impl luban_lib::table::Table for TbBuff {
    type Value = std::sync::Arc<crate::Buff>;
}
pub type TbBuffKey = i32;
#[derive(Debug, Default, Clone, bevy::reflect::Reflect, bevy::prelude::Component)]
pub struct TbBuffRow {
    pub key: TbBuffKey,
    pub data: Option<std::sync::Arc<crate::Buff>>,
}

impl TbBuffRow {
    pub fn new(key: TbBuffKey, data: Option<std::sync::Arc<crate::Buff>>) -> Self {
        Self { key, data }
    }

    pub fn key(&self) -> &TbBuffKey {
        &self.key
    }

    pub fn set_key(&mut self, key: TbBuffKey) {
        self.key = key;
    }

    pub fn set_data(&mut self, data: Option<std::sync::Arc<crate::Buff>>) {
        self.data = data;
    }

    pub fn get_data(&self) -> Option<std::sync::Arc<crate::Buff>> {
        self.data.clone()
    }

    pub fn data(&self) -> std::sync::Arc<crate::Buff> {
        self.data.clone().unwrap()
    }
}

impl luban_lib::table::MapTable for TbBuff {
    type Key = TbBuffKey;
    type List = Vec<std::sync::Arc<crate::Buff>>;
    type Map = bevy::utils::HashMap<Self::Key, Self::Value>;

    fn get_row(&self, key: &Self::Key) -> Option<Self::Value> {
        self.data_map.get(key).map(|x| x.clone())
    }

    fn get_data_list(&self) -> &Self::List {
        &self.data_list
    }

    fn get_data_map(&self) -> &Self::Map {
        &self.data_map
    }
}

#[derive(Debug, Default)]
pub struct TbBuffLoader;

impl bevy::asset::AssetLoader for TbBuffLoader {
    type Asset = TbBuff;

    type Settings = ();

    type Error = TableLoaderError;

    async fn load<'a>(
        &'a self,
        reader: &'a mut bevy::asset::io::Reader<'_>,
        settings: &'a Self::Settings,
        load_context: &'a mut bevy::asset::LoadContext<'_>,
    ) -> Result<Self::Asset, Self::Error> {
        bevy::log::info!("TbBuffLoader loading start");
        let mut bytes = Vec::new();
        use bevy::asset::AsyncReadExt;
        reader.read_to_end(&mut bytes).await?;
        let buf = luban_lib::ByteBuf::new(bytes);
        let tb = TbBuff::new(buf).unwrap();
        bevy::log::info!("TbBuffLoader loading over");
        Ok(tb)
    }

    fn extensions(&self) -> &[&str] {
        &["bytes"]
    }
}
