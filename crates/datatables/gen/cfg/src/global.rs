
/*!
<auto-generated>
    This code was generated by a tool.
    Changes to this file may cause incorrect behavior and will be lost if
    the code is regenerated.
</auto-generated>
*/


use super::*;
use luban_lib::prelude::*;
use serde::Deserialize;
use bevy::prelude::*;
use bevy::asset::AsyncReadExt;








#[derive(Debug, bevy::asset::Asset, bevy::reflect::TypePath)]
pub struct TbGlobal {
    pub data: std::sync::Arc<crate::Global>,
}

impl TbGlobal {
    pub fn new(mut buf: ByteBuf) -> Result<TbGlobal, LubanError> {
        let n = buf.read_size();
        if n != 1 { return Err(LubanError::Table(format!("table mode=one, but size != 1"))); }
        let data = std::sync::Arc::new(crate::Global::new(&mut buf)?);
        Ok(TbGlobal { data })
    }
}

impl Table for TbGlobal {
    type Value = std::sync::Arc<crate::Global>;
}

impl OneTable for TbGlobal {
    fn get_data(&self) -> Self::Value {
        self.data.clone()
    }
}


#[derive(Debug, Default)]
pub struct TbGlobalLoader;

impl bevy::asset::AssetLoader for TbGlobalLoader {
    type Asset = TbGlobal;

    type Settings = ();

    type Error = TableLoaderError;

    async fn load<'a>(
        &'a self,
        reader: &'a mut bevy::asset::io::Reader<'_>,
        settings: &'a Self::Settings,
        load_context: &'a mut bevy::asset::LoadContext<'_>,
    ) -> Result<Self::Asset, Self::Error> {
        info!("TbGlobalLoader loading start");
        let mut bytes = Vec::new();
        reader.read_to_end(&mut bytes).await?;
        let buf = ByteBuf::new(bytes);
        let tb = TbGlobal::new(buf).unwrap();
        info!("TbGlobalLoader loading over");
        Ok(tb)
    }

    fn extensions(&self) -> &[&str] {
        &["bytes"]
    }
}


