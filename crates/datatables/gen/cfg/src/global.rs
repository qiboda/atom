
/*!
<auto-generated>
    This code was generated by a tool.
    Changes to this file may cause incorrect behavior and will be lost if
    the code is regenerated.
</auto-generated>
*/


use super::*;

#[derive(bevy::reflect::Reflect, Debug)]
pub struct Global {
    /// 参数1
    pub x1: i32,
    /// 道具
    pub x2: i32,
    pub x3: i32,
    pub x4: i32,
    pub x5: i32,
    pub x6: i32,
    pub x7: Vec<i32>,
}

impl Global{
    pub fn new(json: &serde_json::Value) -> Result<Global, LubanError> {
        let x1 = (json["x1"].as_i64().unwrap() as i32);
        let x2 = (json["x2"].as_i64().unwrap() as i32);
        let x3 = (json["x3"].as_i64().unwrap() as i32);
        let x4 = (json["x4"].as_i64().unwrap() as i32);
        let x5 = (json["x5"].as_i64().unwrap() as i32);
        let x6 = (json["x6"].as_i64().unwrap() as i32);
        let x7 = json["x7"].as_array().unwrap().iter().map(|field| (field.as_i64().unwrap() as i32)).collect();
        
        Ok(Global { x1, x2, x3, x4, x5, x6, x7, })
    }
}


#[derive(Debug, bevy::reflect::Reflect, bevy::asset::Asset)]
pub struct TbGlobal {
    pub data: std::sync::Arc<crate::global::Global>,
}

impl TbGlobal {
    pub fn new(json: &serde_json::Value) -> Result<TbGlobal, LubanError> {
        let json = json.as_array().unwrap();
        let n = json.len();
        if n != 1 { return Err(LubanError::Table(format!("table mode=one, but size != 1"))); }
        let data = std::sync::Arc::new(crate::global::Global::new(&json[0])?);
        Ok(TbGlobal { data })
    }
}

impl luban_lib::table::Table for TbGlobal {
    type Value = std::sync::Arc<crate::global::Global>;
}

impl luban_lib::table::OneTable for TbGlobal {
    fn get_data(&self) -> Self::Value {
        self.data.clone()
    }
}


#[derive(Debug, Default)]
pub struct TbGlobalLoader;

impl bevy::asset::AssetLoader for TbGlobalLoader {
    type Asset = TbGlobal;

    type Settings = ();

    type Error = TableLoaderError;

    async fn load(
        &self,
        reader: &mut dyn bevy::asset::io::Reader,
        settings: &Self::Settings,
        load_context: &mut bevy::asset::LoadContext<'_>,
    ) -> Result<Self::Asset, Self::Error> {
        bevy::log::info!("TbGlobalLoader loading start");
        let mut bytes = Vec::new();
        use bevy::asset::AsyncReadExt;
        reader.read_to_end(&mut bytes).await?;
        let t = serde_json::from_slice::<serde_json::Value>(&bytes)?;
        let tb = TbGlobal::new(&t).unwrap();
        bevy::log::info!("TbGlobalLoader loading over");
        Ok(tb)
    }

    fn extensions(&self) -> &[&str] {
        &["json"]
    }
}


