
/*!
<auto-generated>
    This code was generated by a tool.
    Changes to this file may cause incorrect behavior and will be lost if
    the code is regenerated.
</auto-generated>
*/


use super::*;

///camp relationship
#[derive(Debug, Hash, Eq, PartialEq, macros::EnumFromNum)]
pub enum RelationShipType {
    None = 0,
    Hostility = 1,
    Friendly = 2,
}

impl From<i32> for RelationShipType {
    fn from(value: i32) -> Self {        match value { 
            0 => RelationShipType::None,
            1 => RelationShipType::Hostility,
            2 => RelationShipType::Friendly,
            _ => panic!("Invalid value for RelationShipType:{}", value),
        }
    }
}








#[derive(Debug, bevy::asset::Asset, bevy::reflect::TypePath)]
pub struct TbRelationShip {
    pub data_list: Vec<std::sync::Arc<crate::RelationShip>>,
    pub data_map_union: bevy::utils::HashMap<(i32, i32), std::sync::Arc<crate::RelationShip>>,
}

impl TbRelationShip {
    pub fn new(mut buf: luban_lib::ByteBuf) -> Result<TbRelationShip, LubanError> {
        let mut data_list: Vec<std::sync::Arc<crate::RelationShip>> = vec![];

        for x in (0..buf.read_size()).rev() {
            let row = std::sync::Arc::new(crate::RelationShip::new(&mut buf)?);
            data_list.push(row.clone());
        }
        let mut data_map_union: bevy::utils::HashMap<(i32, i32), std::sync::Arc<crate::RelationShip>> = Default::default();
        for x in &data_list {
            data_map_union.insert((x.active_camp, x.passive_camp.clone()), x.clone());
        }

    Ok(TbRelationShip { 
            data_list,
            data_map_union,
        })
    }

    pub fn get(&self, key: &(i32, i32)) -> Option<std::sync::Arc<crate::RelationShip>> {
        self.data_map_union.get(key).map(|x| x.clone())
    }
}

impl luban_lib::table::Table for TbRelationShip {
    type Value = std::sync::Arc<crate::RelationShip>;
}
impl luban_lib::table::ListTable for TbRelationShip {}


pub type TbRelationShipKey = (i32, i32);
#[derive(Debug, Default, bevy::prelude::Component)]
pub struct TbRelationShipRow {
    pub key: TbRelationShipKey,
    pub data: Option<std::sync::Arc<crate::RelationShip>>,
}
impl luban_lib::table::MultiUnionIndexListTable for TbRelationShip {
    type Key = TbRelationShipKey;

    fn get_row_by_key(&self, key: &Self::Key) -> Option<Self::Value> {
        self.data_map_union.get(key).map(|x| x.clone())
    }
}


#[derive(Debug, Default)]
pub struct TbRelationShipLoader;

impl bevy::asset::AssetLoader for TbRelationShipLoader {
    type Asset = TbRelationShip;

    type Settings = ();

    type Error = TableLoaderError;

    async fn load<'a>(
        &'a self,
        reader: &'a mut bevy::asset::io::Reader<'_>,
        settings: &'a Self::Settings,
        load_context: &'a mut bevy::asset::LoadContext<'_>,
    ) -> Result<Self::Asset, Self::Error> {
        bevy::log::info!("TbRelationShipLoader loading start");
        let mut bytes = Vec::new();
        use bevy::asset::AsyncReadExt;
        reader.read_to_end(&mut bytes).await?;
        let buf = luban_lib::ByteBuf::new(bytes);
        let tb = TbRelationShip::new(buf).unwrap();
        bevy::log::info!("TbRelationShipLoader loading over");
        Ok(tb)
    }

    fn extensions(&self) -> &[&str] {
        &["bytes"]
    }
}


