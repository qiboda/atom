
/*!
<auto-generated>
    This code was generated by a tool.
    Changes to this file may cause incorrect behavior and will be lost if
    the code is regenerated.
</auto-generated>
*/

pub mod prelude{
    pub use crate::*;
    pub use crate::item::*;
    pub use crate::test::*;
}

type AbstractBase = dyn std::any::Any + Sync + Send;

pub trait GetBase<'a, T> {
    fn get_base(&'a self) -> Result<T, LubanError>;
}

#[derive(Debug)]
pub enum LubanError {
    Loader(String),
    Table(String),
    Bean(String),
    Polymorphic(String),
    Unknown(String),
}

impl std::fmt::Display for LubanError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.write_str(match self {
            LubanError::Loader(msg) |
            LubanError::Table(msg) |
            LubanError::Bean(msg) |
            LubanError::Polymorphic(msg) |
            LubanError::Unknown(msg) => msg,
        })
    }
}

pub struct Tables{
    pub TbItem: std::sync::Arc<crate::item::TbItem>,
}

impl Tables {
    pub fn new<T: Fn(&str) -> Result<serde_json::Value, LubanError>>(loader: T) -> Result<Tables, LubanError> {
        Ok(Tables {
            TbItem: crate::item::TbItem::new(&loader("item_tbitem")?)?,
        })
    }
}
pub mod item;
pub mod test;

use serde::Deserialize;

#[derive(Debug)]
pub struct vector2 {
    pub x: f32,
    pub y: f32,
}

impl vector2{
    pub fn new(json: &serde_json::Value) -> Result<vector2, LubanError> {
        let x = (json["x"].as_f64().unwrap() as f32);
        let y = (json["y"].as_f64().unwrap() as f32);
        
        Ok(vector2 { x, y, })
    }
}

#[derive(Debug)]
pub struct vector3 {
    pub x: f32,
    pub y: f32,
    pub z: f32,
}

impl vector3{
    pub fn new(json: &serde_json::Value) -> Result<vector3, LubanError> {
        let x = (json["x"].as_f64().unwrap() as f32);
        let y = (json["y"].as_f64().unwrap() as f32);
        let z = (json["z"].as_f64().unwrap() as f32);
        
        Ok(vector3 { x, y, z, })
    }
}

#[derive(Debug)]
pub struct vector4 {
    pub x: f32,
    pub y: f32,
    pub z: f32,
    pub w: f32,
}

impl vector4{
    pub fn new(json: &serde_json::Value) -> Result<vector4, LubanError> {
        let x = (json["x"].as_f64().unwrap() as f32);
        let y = (json["y"].as_f64().unwrap() as f32);
        let z = (json["z"].as_f64().unwrap() as f32);
        let w = (json["w"].as_f64().unwrap() as f32);
        
        Ok(vector4 { x, y, z, w, })
    }
}

#[derive(Debug)]
pub struct Item {
    /// 这是id
    pub id: i32,
    /// 名字
    pub name: String,
    /// 描述
    pub desc: String,
    /// 价格
    pub price: i32,
    /// 引用当前表
    pub upgrade_to_item_id: i32,
    /// 过期时间
    pub expire_time: Option<u64>,
    /// 能否批量使用
    pub batch_useable: bool,
    /// 品质
    pub quality: crate::item::EQuality,
    /// 道具兑换配置
    pub exchange_stream: crate::item::ItemExchange,
    pub exchange_list: Vec<crate::item::ItemExchange>,
    /// 道具兑换配置
    pub exchange_column: crate::item::ItemExchange,
}

impl Item{
    pub fn new(json: &serde_json::Value) -> Result<Item, LubanError> {
        let id = (json["id"].as_i64().unwrap() as i32);
        let name = json["name"].as_str().unwrap().to_string();
        let desc = json["desc"].as_str().unwrap().to_string();
        let price = (json["price"].as_i64().unwrap() as i32);
        let upgrade_to_item_id = (json["upgrade_to_item_id"].as_i64().unwrap() as i32);
        let mut expire_time = None; if let Some(value) = json.get("expire_time") { expire_time = Some((json["expire_time"].as_i64().unwrap() as u64)); }
        let batch_useable = json["batch_useable"].as_bool().unwrap();
        let quality = json["quality"].as_i64().unwrap().into();
        let exchange_stream = crate::item::ItemExchange::new(&json["exchange_stream"])?;
        let exchange_list = json["exchange_list"].as_array().unwrap().iter().map(|field| crate::item::ItemExchange::new(&field).unwrap()).collect();
        let exchange_column = crate::item::ItemExchange::new(&json["exchange_column"])?;
        
        Ok(Item { id, name, desc, price, upgrade_to_item_id, expire_time, batch_useable, quality, exchange_stream, exchange_list, exchange_column, })
    }
}


